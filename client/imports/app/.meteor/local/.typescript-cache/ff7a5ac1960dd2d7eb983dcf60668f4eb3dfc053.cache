{"code":"var http_1 = require('@angular/http');\r\nvar testing_1 = require('@angular/http/testing');\r\nexports.fakeBackendProvider = {\r\n    // use fake backend in place of Http service for backend-less development\r\n    provide: http_1.Http,\r\n    useFactory: function (backend, options) {\r\n        // array in local storage for registered users\r\n        var users = JSON.parse(localStorage.getItem('users')) || [];\r\n        // configure fake backend\r\n        backend.connections.subscribe(function (connection) {\r\n            // wrap in timeout to simulate server api call\r\n            setTimeout(function () {\r\n                // authenticate\r\n                if (connection.request.url.endsWith('/api/authenticate') && connection.request.method === http_1.RequestMethod.Post) {\r\n                    // get parameters from post request\r\n                    var params_1 = JSON.parse(connection.request.getBody());\r\n                    // find if any user matches login credentials\r\n                    var filteredUsers = users.filter(function (user) {\r\n                        return user.username === params_1.username && user.password === params_1.password;\r\n                    });\r\n                    if (filteredUsers.length) {\r\n                        // if login details are valid return 200 OK with user details and fake jwt token\r\n                        var user = filteredUsers[0];\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({\r\n                            status: 200,\r\n                            body: {\r\n                                id: user.id,\r\n                                username: user.username,\r\n                                firstName: user.firstName,\r\n                                lastName: user.lastName,\r\n                                token: 'fake-jwt-token'\r\n                            }\r\n                        })));\r\n                    }\r\n                    else {\r\n                        // else return 400 bad request\r\n                        connection.mockError(new Error('Username or password is incorrect'));\r\n                    }\r\n                }\r\n                // get users\r\n                if (connection.request.url.endsWith('/api/users') && connection.request.method === http_1.RequestMethod.Get) {\r\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\r\n                    if (connection.request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 200, body: users })));\r\n                    }\r\n                    else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 401 })));\r\n                    }\r\n                }\r\n                // get user by id\r\n                if (connection.request.url.match(/\\/api\\/users\\/\\d+$/) && connection.request.method === http_1.RequestMethod.Get) {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (connection.request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        var urlParts = connection.request.url.split('/');\r\n                        var id_1 = parseInt(urlParts[urlParts.length - 1]);\r\n                        var matchedUsers = users.filter(function (user) { return user.id === id_1; });\r\n                        var user = matchedUsers.length ? matchedUsers[0] : null;\r\n                        // respond 200 OK with user\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 200, body: user })));\r\n                    }\r\n                    else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 401 })));\r\n                    }\r\n                }\r\n                // create user\r\n                if (connection.request.url.endsWith('/api/users') && connection.request.method === http_1.RequestMethod.Post) {\r\n                    // get new user object from post body\r\n                    var newUser_1 = JSON.parse(connection.request.getBody());\r\n                    // validation\r\n                    var duplicateUser = users.filter(function (user) { return user.username === newUser_1.username; }).length;\r\n                    if (duplicateUser) {\r\n                        return connection.mockError(new Error('Username \"' + newUser_1.username + '\" is already taken'));\r\n                    }\r\n                    // save new user\r\n                    newUser_1.id = users.length + 1;\r\n                    users.push(newUser_1);\r\n                    localStorage.setItem('users', JSON.stringify(users));\r\n                    // respond 200 OK\r\n                    connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 200 })));\r\n                }\r\n                // delete user\r\n                if (connection.request.url.match(/\\/api\\/users\\/\\d+$/) && connection.request.method === http_1.RequestMethod.Delete) {\r\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\r\n                    if (connection.request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\r\n                        // find user by id in users array\r\n                        var urlParts = connection.request.url.split('/');\r\n                        var id = parseInt(urlParts[urlParts.length - 1]);\r\n                        for (var i = 0; i < users.length; i++) {\r\n                            var user = users[i];\r\n                            if (user.id === id) {\r\n                                // delete user\r\n                                users.splice(i, 1);\r\n                                localStorage.setItem('users', JSON.stringify(users));\r\n                                break;\r\n                            }\r\n                        }\r\n                        // respond 200 OK\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 200 })));\r\n                    }\r\n                    else {\r\n                        // return 401 not authorised if token is null or invalid\r\n                        connection.mockRespond(new http_1.Response(new http_1.ResponseOptions({ status: 401 })));\r\n                    }\r\n                }\r\n            }, 500);\r\n        });\r\n        return new http_1.Http(backend, options);\r\n    },\r\n    deps: [testing_1.MockBackend, http_1.BaseRequestOptions]\r\n};\r\n//# sourceMappingURL=fake-backend.js.map","sourceMap":{"version":3,"file":"fake-backend.js","sourceRoot":"","sources":["client/imports/app/_helpers/fake-backend.ts"],"names":[],"mappings":"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","sourcesContent":["import { Http, BaseRequestOptions, Response, ResponseOptions, RequestMethod } from '@angular/http';\nimport { MockBackend, MockConnection } from '@angular/http/testing';\n \nexport let fakeBackendProvider = {\n    // use fake backend in place of Http service for backend-less development\n    provide: Http,\n    useFactory: function (backend: MockBackend, options: BaseRequestOptions) {\n        // array in local storage for registered users\n        let users: any[] = JSON.parse(localStorage.getItem('users')) || [];\n \n        // configure fake backend\n        backend.connections.subscribe((connection: MockConnection) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(() => {\n \n                // authenticate\n                if (connection.request.url.endsWith('/api/authenticate') && connection.request.method === RequestMethod.Post) {\n                    // get parameters from post request\n                    let params = JSON.parse(connection.request.getBody());\n \n                    // find if any user matches login credentials\n                    let filteredUsers = users.filter(user => {\n                        return user.username === params.username && user.password === params.password;\n                    });\n \n                    if (filteredUsers.length) {\n                        // if login details are valid return 200 OK with user details and fake jwt token\n                        let user = filteredUsers[0];\n                        connection.mockRespond(new Response(new ResponseOptions({\n                            status: 200,\n                            body: {\n                                id: user.id,\n                                username: user.username,\n                                firstName: user.firstName,\n                                lastName: user.lastName,\n                                token: 'fake-jwt-token'\n                            }\n                        })));\n                    } else {\n                        // else return 400 bad request\n                        connection.mockError(new Error('Username or password is incorrect'));\n                    }\n                }\n \n                // get users\n                if (connection.request.url.endsWith('/api/users') && connection.request.method === RequestMethod.Get) {\n                    // check for fake auth token in header and return users if valid, this security is implemented server side in a real application\n                    if (connection.request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n                        connection.mockRespond(new Response(new ResponseOptions({ status: 200, body: users })));\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        connection.mockRespond(new Response(new ResponseOptions({ status: 401 })));\n                    }\n                }\n \n                // get user by id\n                if (connection.request.url.match(/\\/api\\/users\\/\\d+$/) && connection.request.method === RequestMethod.Get) {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (connection.request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = connection.request.url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        let matchedUsers = users.filter(user => { return user.id === id; });\n                        let user = matchedUsers.length ? matchedUsers[0] : null;\n \n                        // respond 200 OK with user\n                        connection.mockRespond(new Response(new ResponseOptions({ status: 200, body: user })));\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        connection.mockRespond(new Response(new ResponseOptions({ status: 401 })));\n                    }\n                }\n \n                // create user\n                if (connection.request.url.endsWith('/api/users') && connection.request.method === RequestMethod.Post) {\n                    // get new user object from post body\n                    let newUser = JSON.parse(connection.request.getBody());\n \n                    // validation\n                    let duplicateUser = users.filter(user => { return user.username === newUser.username; }).length;\n                    if (duplicateUser) {\n                        return connection.mockError(new Error('Username \"' + newUser.username + '\" is already taken'));\n                    }\n \n                    // save new user\n                    newUser.id = users.length + 1;\n                    users.push(newUser);\n                    localStorage.setItem('users', JSON.stringify(users));\n \n                    // respond 200 OK\n                    connection.mockRespond(new Response(new ResponseOptions({ status: 200 })));\n                }\n \n                // delete user\n                if (connection.request.url.match(/\\/api\\/users\\/\\d+$/) && connection.request.method === RequestMethod.Delete) {\n                    // check for fake auth token in header and return user if valid, this security is implemented server side in a real application\n                    if (connection.request.headers.get('Authorization') === 'Bearer fake-jwt-token') {\n                        // find user by id in users array\n                        let urlParts = connection.request.url.split('/');\n                        let id = parseInt(urlParts[urlParts.length - 1]);\n                        for (let i = 0; i < users.length; i++) {\n                            let user = users[i];\n                            if (user.id === id) {\n                                // delete user\n                                users.splice(i, 1);\n                                localStorage.setItem('users', JSON.stringify(users));\n                                break;\n                            }\n                        }\n \n                        // respond 200 OK\n                        connection.mockRespond(new Response(new ResponseOptions({ status: 200 })));\n                    } else {\n                        // return 401 not authorised if token is null or invalid\n                        connection.mockRespond(new Response(new ResponseOptions({ status: 401 })));\n                    }\n                }\n \n            }, 500);\n \n        });\n \n        return new Http(backend, options);\n    },\n    deps: [MockBackend, BaseRequestOptions]\n};"]},"version":"1","isExternal":true,"references":{"files":[],"modules":[],"typings":[]},"diagnostics":{"syntacticErrors":[],"semanticErrors":[{"code":2304,"fileName":"client/imports/app/_helpers/fake-backend.ts","message":"Cannot find name 'MockBackend'.","line":7,"column":36},{"code":2304,"fileName":"client/imports/app/_helpers/fake-backend.ts","message":"Cannot find name 'BaseRequestOptions'.","line":7,"column":58},{"code":2304,"fileName":"client/imports/app/_helpers/fake-backend.ts","message":"Cannot find name 'MockConnection'.","line":12,"column":52}]},"hash":"ff7a5ac1960dd2d7eb983dcf60668f4eb3dfc053"}